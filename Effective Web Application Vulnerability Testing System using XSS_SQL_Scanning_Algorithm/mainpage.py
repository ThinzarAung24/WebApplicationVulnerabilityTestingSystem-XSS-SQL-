from tkinter import ttk
import tkinter
from tkinter import *
from tkinter import messagebox
from tkinter import scrolledtext
import time
import sys
import requests, re
import urllib.parse
from urllib import parse
from urllib.request import urlopen
from urllib.parse import urljoin
from urllib.parse import urlparse
from html.parser import HTMLParser
from urllib.parse import urljoin
from bs4 import BeautifulSoup
from file_read_write_delete_fun import *
from naive_pattern_matching_method import *
from testing_accuracy import *

# http://bired.org/aboutUs.php?id=5
window = tkinter.Tk()
window.title("XSS_SQL_Scanning_Algorithm")
window.geometry("900x600")

window.configure(bg="#187bcd")
# window.configure(bg="#E5E4E2")
# https://www.afrims.go.th/
# https://www.yru.ac.th/th
delete_file_contents("linkfile.txt")
delete_file_contents("formLink.txt")
delete_file_contents("attributes.txt")
delete_file_contents("base_url.txt")
delete_file_contents("vulnerability.txt")
delete_file_contents("link_with_param.txt")


def exit():
    sys.exit()


def show_result_in_scrolled_tab(i, show_result):
    i.insert(tkinter.INSERT, show_result)
    i.insert(tkinter.INSERT, "\n")
    window.update()
    time.sleep(0.5)


verify_ssl = False
# payload
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# SQL Quotes
payload_of_SQL = ["\'", "\"", "`", "\\"]
patternList_of_SQL = ["You have an error in your SQL syntax",
                      "supplied argument is not a valid MySQL result resource",
                      "check the manual that corresponds to your MySQL",
                      "mysql_fetch_array(): supplied argument is not a valid MySQL",
                      "function fetch_row()",
                      "Microsoft OLE DB Provider for ODBC Drivers error",
                      "mysqli_fetch_array()",
                      "mysql_num_rows()",
                      "mysql_free_result()",
                      "<b>Warning</b>:  SQLite3",
                      "unrecognized token:",
                      "Unable to prepare statement:",
                      "ERROR:  syntax error"
                      ]
# TimeBase Payload
TimeBase = [
    "SELECT SLEEP(2)",  # MySQL
    "SELECT PG_SLEEP(2)",  # PostGreSQL
    "WAITFOR DELAY '00:00:01'",  # MSSQL
    "sqlite3_sleep(2000)"  # SQLite3
]
# Blind Base Payload
BlindTrue = ["AND 1=1", ]
BlindFalse = ["AND 1=2"]

SQLComments = ["--",
               "-- -",
               "#",
               ";"
               ]

error_message_of_SQL = "Possible SQL VULNERABILITY"

payload_of_XSS = ["aaaaa<>\'", "aaaaaa<>\"", "aaaaaaaa\"\'", "<svg \"ons>", " onfocus=\"alert(1);"
                  ,"<svg/onload=alert(1)>"]
patternList_of_XSS = ["aaaaa<>\'", "aaaaaa<>\"", "aaaaaaaa\"\'", "<svg \"ons>", " onfocus=\"alert(1);",
                      "<svg/onload=alert(1)>"]
error_message_of_XSS = "Possible XSS VULNERABILITY"


# -----------------------------------------------------------------------------------------------------------------------------------------------------------------

# class ( for find links )
# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
class LinkFinder(HTMLParser):

    def __init__(self, base_url):
        super().__init__()
        self.base_url = base_url

    # When we call HTMLParser feed() this function is called when it encounters an opening tag <a>
    def handle_starttag(self, tag, attrs):

        links = []
        linksForm = []
        linksInputAttr = []
        repeatURL = []
        visited = set()

        if tag == 'a':
            for (attribute, value) in attrs:
                if attribute == 'href':
                    url = parse.urljoin(self.base_url, value)
                    if "#" in url:
                        url = url.split("#")[0]
                    links.append(url)
                    write_file("linkfile.txt", url + "\n")
                    for i in links:
                        if self.base_url != i:
                            try:
                                res = requests.get(i,verify=verify_ssl)
                                response = re.findall('''<a\s+(?:[^>]*?\s+)?href="([^"]*)"''', res.text)
                                for j, a_href in enumerate(response):
                                    link = urljoin(self.base_url, a_href)
                                    if "#" in link:
                                        link = link.split("#")[0]
                                    if link in visited:
                                        continue
                                    if link == self.base_url:
                                        continue
                                    if link not in repeatURL:
                                        repeatURL.append(link)
                                    show_result_in_scrolled_tab(scrolled_text_tab1, link)
                                    visited.add(link)
                                    write_file("linkfile.txt", link + "\n")
                            except Exception as e:
                                pass
        if tag == 'input':
            for (attribute, value) in attrs:
                if attribute == 'id':
                    # url = parse.urljoin(self.base_url, value)
                    linksInputAttr.append(value)
                if attribute == 'name':
                    linksInputAttr.append(value)
        if tag == 'select':
            for (attribute, value) in attrs:
                if attribute == 'id':
                    linksInputAttr.append(value)
                if attribute == 'name':
                    linksInputAttr.append(value)
        if tag == 'textarea':
            for (attribute, value) in attrs:
                if attribute == 'id':
                    linksInputAttr.append(value)
                if attribute == 'name':
                    linksInputAttr.append(value)
        if tag == 'checkbox':
            for (attribute, value) in attrs:
                if attribute == 'id':
                    linksInputAttr.append(value)
                if attribute == 'name':
                    linksInputAttr.append(value)
        if tag == 'button':
            for (attribute, value) in attrs:
                if attribute == 'id':
                    linksInputAttr.append(value)
                if attribute == 'name':
                    linksInputAttr.append(value)
        if tag == 'form':
            for (attribute, value) in attrs:
                if attribute == 'action':
                    base = urljoin(self.base_url, '.')
                    url = parse.urljoin(base, value)
                    linksForm.append(url)

        for j in linksForm:
            write_file("formLink.txt", j + "\n")

        for k in linksInputAttr:
            write_file("attributes.txt", k + "\n")


# --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Payload Function for Blind Base and Time Base
def PayloadsTimeBase():
    result = []
    for payload in TimeBase:
        for comment in SQLComments:
            result.append(";" + payload + comment)

    return result


def PayloadsBlindBase():
    result = []
    btrue = []
    bfalse = []

    for payload in BlindTrue:
        for comment in SQLComments:
            btrue.append(" " + payload + comment)
    for payload in BlindFalse:
        for comment in SQLComments:
            bfalse.append(" " + payload + comment)

    if len(btrue) > len(bfalse):
        for i in range(0, len(bfalse)):
            result.append(btrue[i])
            result.append(bfalse[i])
    else:
        for i in range(0, len(btrue)):
            result.append([btrue[i], bfalse[i]])

    return result


# --------------------------------------------------------------------
# # Function call for Time Base and Blind Base
# time = PayloadsTimeBase()
# blind = PayloadsBlindBase()


# ---------------------------------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------------------------------
# Get HTML code in Response
def GetHTML(url):
    r = requests.get(url, verify=verify_ssl)
    return r.text


# ----------------------------------------------------------------------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------------------------------------------------------
# Check Blind Base Function
def checkblind(url, blindlist):
    try:
        for ready_links in url:
            html = GetHTML(ready_links)
            blindtrue = GetHTML(ready_links + blindlist[0])
            blindfalse = GetHTML(ready_links + blindlist[1])
            if (blindtrue == html) and (blindtrue != blindfalse):
                # print(ready_links + str(blindlist[1]) + str("possible blind SQL"))
                show_result_in_scrolled_tab(scrolled_text_tab3,
                                            ready_links + str(blindlist[1]) + str("  possible blind SQL"))
                file = open('vulnerability.txt', 'a+')
                file.write(ready_links+str(blindlist[1])+"\n")
            else:
                # print(ready_links + str(blindlist[0]))
                show_result_in_scrolled_tab(scrolled_text_tab3, ready_links + str(blindlist[0]))
    except Exception as e:
        pass

# -----------------------------------------------------------------------------------------------------------------------------------------------
# Check Time Base Function
def checktime(url, timelist):
    try:
        for ready_links in url:
            payloadurl = ready_links + timelist
            starttime = time.time()
            page = GetHTML(payloadurl)
            endtime = time.time()
            if (endtime - starttime) >= ((endtime - starttime) + 2):
                # print(payloadurl + "Possible Time")
                show_result_in_scrolled_tab(scrolled_text_tab3, payloadurl + "Possible Time")
                file = open('vulnerability.txt', 'a+')
                file.write(payloadurl+"\n")
                file.close()
            # elif ((endtime-starttime)*3+2> (endtime-starttime)):
            #     continue
            else:
                # print(payloadurl)
                show_result_in_scrolled_tab(scrolled_text_tab3,payloadurl)

    except TimeoutError as e:
        pass
    except ConnectionError as e:
        pass
    except Exception as e:
        pass


# --------------------------------------------------------------------------------------------------------------------------------------------
# Testing with payloads (testing_possible_vulnerability.py)
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
def splitUrl(testToReadyLinks, testToLinkForm, attribute, payload, patternList, error_message, base_url):
    try:
        hidden_parameters_with_links = []
        hidden_parameters_links_with_value = []

        if testToLinkForm:
            # print("Hidden link ----\|/----")
            # print(testToLinkForm)
            show_result_in_scrolled_tab(scrolled_text_tab2, testToLinkForm)
            for testToFormLink in testToLinkForm:
                for attributes in attribute:
                    # print("hidden link with hidden parameters")
                    hidden_parameters_links = testToFormLink + "?" + attributes + "=xxxx"
                    hidden_parameters_links_with_value.append(hidden_parameters_links)

        if attribute:
            # print("Hidden parameters ----\|/---- ")
            for attributes in attribute:
                # print(attributes)
                hidden_parameters = base_url + "?" + attributes + "=xxxx"
                hidden_parameters_links_with_value.append(hidden_parameters)

        test_to_ready_links = hidden_parameters_links_with_value + testToReadyLinks

        # Start testing from this
        print("Let's Start to Test !!!! ")
        window.title("Let's Start to Test !!!!")
        r = ""
        for testToReadyLink in test_to_ready_links:
            urlparsed = urlparse(testToReadyLink)
            try:
                parms = dict([item.split("=") for item in urlparsed[4].split("&")])
                show_result_in_scrolled_tab(scrolled_text_tab3, parms)
            except ValueError:
                pass

            parm_keys = parms.keys()
            parmvalue = parms.values()

            if len(parms) == 1:
                for p in payload:
                    vparam = urlparsed.scheme + "://" + urlparsed.netloc + urlparsed.path + "?" + list(parm_keys)[
                        0] + "=" + \
                             list(parmvalue)[0] + p
                    # print(vparam)
                    show_result_in_scrolled_tab(scrolled_text_tab3, vparam)
                    res = requests.get(vparam, verify=verify_ssl)
                    for pattern in patternList:
                        data = (res.text).encode('utf8')
                        result = search(pattern, data.decode('utf8'))
                        if result:
                            # print(error_message + pattern)
                            show_result_in_scrolled_tab(scrolled_text_tab3, vparam + " " + error_message)
                            file = open('vulnerability.txt', 'a+')
                            file.write(vparam + "\n")
                            file.close()
                            r = error_message
            elif len(parms) == 2:
                for p in payload:
                    vparam = urlparsed.scheme + "://" + urlparsed.netloc + urlparsed.path + "?" + list(parm_keys)[
                        0] + "=" + \
                             list(parmvalue)[
                                 0] + p + "&" + list(parm_keys)[1] + "=" + list(parmvalue)[1]
                    show_result_in_scrolled_tab(scrolled_text_tab3, vparam)
                for p in payload:
                    vparam = urlparsed.scheme + "://" + urlparsed.netloc + urlparsed.path + "?" + list(parm_keys)[
                        0] + "=" + \
                             list(parmvalue)[0] \
                             + "&" + list(parm_keys)[1] + "=" + list(parmvalue)[1] + p
                    show_result_in_scrolled_tab(scrolled_text_tab3, vparam)
                    res = requests.get(vparam,verify=verify_ssl)
                    for pattern in patternList:
                        data = (res.text).encode('utf8')
                        result = search(pattern, data.decode('utf8'))
                        if result:
                            # print(error_message + pattern)
                            show_result_in_scrolled_tab(scrolled_text_tab3, vparam + error_message)
                            file = open('vulnerability.txt', 'a+')
                            file.write(vparam + "\n")
                            file.close()
                            r = error_message
            elif len(parms) == 3:
                for p in payload:
                    vparam = urlparsed.scheme + "://" + urlparsed.netloc + urlparsed.path + "?" + list(parm_keys)[
                        0] + "=" + \
                             list(parmvalue)[0] + p + "&" + list(parm_keys)[1] + "=" + list(parmvalue)[1] + "&" + \
                             list(parm_keys)[2] + "=" + \
                             list(parmvalue)[2]
                    show_result_in_scrolled_tab(scrolled_text_tab3, vparam)
                for p in payload:
                    vparam = urlparsed.scheme + "://" + urlparsed.netloc + urlparsed.path + "?" + list(parm_keys)[
                        0] + "=" + \
                             list(parmvalue)[
                                 0] + "&" + list(parm_keys)[1] + "=" + list(parmvalue)[1] + p + "&" + list(parm_keys)[
                                 2] + "=" + list(parmvalue)[2]
                    show_result_in_scrolled_tab(scrolled_text_tab3, vparam)
                for p in payload:
                    vparam = urlparsed.scheme + "://" + urlparsed.netloc + urlparsed.path + "?" + list(parm_keys)[
                        0] + "=" + \
                             list(parmvalue)[
                                 0] + "&" + list(parm_keys)[1] + "=" + list(parmvalue)[1] + "&" + list(parm_keys)[
                                 2] + "=" + \
                             list(parmvalue)[2] + p
                    show_result_in_scrolled_tab(scrolled_text_tab3, vparam)
                    res = requests.get(vparam,verify=verify_ssl)
                    for pattern in patternList:
                        data = (res.text).encode('utf8')
                        result = search(pattern, data.decode('utf8'))
                        if result:
                            # print(error_message + pattern)
                            show_result_in_scrolled_tab(scrolled_text_tab3, vparam +  error_message)
                            file = open('vulnerability.txt', 'a+')
                            file.write(vparam + "\n")
                            file.close()
                            r = error_message

            elif len(parms) == 4:
                for p in payload:
                    vparam = urlparsed.scheme + "://" + urlparsed.netloc + urlparsed.path + "?" + list(parm_keys)[
                        0] + "=" + \
                             list(parmvalue)[0] + p + "&" + list(parm_keys)[1] + "=" + list(parmvalue)[1] + "&" + \
                             list(parm_keys)[2] + "=" + list(parmvalue)[2] + "&" + list(parm_keys)[3] + "=" + \
                             list(parmvalue)[3]
                    show_result_in_scrolled_tab(scrolled_text_tab3, vparam)
                for p in payload:
                    vparam = urlparsed.scheme + "://" + urlparsed.netloc + urlparsed.path + "?" + list(parm_keys)[
                        0] + "=" + \
                             list(parmvalue)[
                                 0] + "&" + list(parm_keys)[1] + "=" + list(parmvalue)[1] + p + "&" + list(parm_keys)[
                                 2] + "=" + list(parmvalue)[2] + "&" + list(parm_keys)[3] + "=" + list(parmvalue)[3]
                    show_result_in_scrolled_tab(scrolled_text_tab3, vparam)
                for p in payload:
                    vparam = urlparsed.scheme + "://" + urlparsed.netloc + urlparsed.path + "?" + list(parm_keys)[
                        0] + "=" + \
                             list(parmvalue)[
                                 0] + "&" + list(parm_keys)[1] + "=" + list(parmvalue)[1] + "&" + list(parm_keys)[
                                 2] + "=" + \
                             list(parmvalue)[2] + p + "&" + list(parm_keys)[3] + "=" + list(parmvalue)[3]
                    show_result_in_scrolled_tab(scrolled_text_tab3, vparam)
                for p in payload:
                    vparam = urlparsed.scheme + "://" + urlparsed.netloc + urlparsed.path + "?" + list(parm_keys)[
                        0] + "=" + list(parmvalue)[0] + "&" + list(parm_keys)[1] + "=" + list(parmvalue)[1] + "&" + \
                             list(parm_keys)[
                                 2] + "=" + list(parmvalue)[2] + "&" + list(parm_keys)[3] + "=" + list(parmvalue)[3] + p
                    show_result_in_scrolled_tab(scrolled_text_tab3, vparam)
                    res = requests.get(vparam,verify=verify_ssl)
                    for pattern in patternList:
                        data = (res.text).encode('utf8')
                        result = search(pattern, data.decode('utf8'))
                        if result:
                            show_result_in_scrolled_tab(scrolled_text_tab3, error_message + pattern)
                            file = open('vulnerability.txt', 'a+')
                            file.write(vparam + "\n")
                            file.close()
                            r = error_message

        if r != str(error_message):
            show_result_in_scrolled_tab(scrolled_text_tab3, "Not Found Any Possible Vulnerability :-) ")
    except Exception as e:
        pass


# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# function
# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
def main_page_click(choose_to_Scan_type, base_url):
    urlparsed = parse.urlparse(base_url)
    scheme = urlparsed.scheme
    target = urlparsed.netloc
    path = urlparsed.path
    baseUrl = "{}://{}{}".format(scheme, target, path)
    # baseUrl = scheme  + target + path
    write_file("base_url.txt", baseUrl)
    # Count time
    startTime = time.time()
    time.perf_counter()
    start = time.time()
    try:
        response = requests.get(base_url,verify=verify_ssl)
        html_bytes = response.text
        html_string = html_bytes
        finder = LinkFinder(base_url)
        finder.feed(html_string)
    except Exception as e:
        print(str(e))

    linkswithParameters = []
    linkswithFormAction = []
    attributes = []
    baseUrl = ""

    tagA = read_file_contents_a("linkfile.txt")
    formTag = read_file_contents("formLink.txt")
    attribute = read_file_contents("attributes.txt")
    base = read_file_contents("base_url.txt")
    for original in base:
        baseUrl = original
        scrolled_text_tab2.insert(tkinter.INSERT, "Target URL -----::------ " + baseUrl + "\n")
        scrolled_text_tab2.insert(tkinter.INSERT, "\n::::::::::::Links with Parameters :::::::::: " + "\n")
        window.update()
        time.sleep(0.025)
    window.title("Let's Move to Paramters with Links Panel !!!")
    for aTag in tagA:
        linkswithParameters.append(aTag.rstrip("\n"))
        write_file("link_with_param.txt", aTag)
        # scrolled_text_tab2.insert(tkinter.INSERT, "\n")
        scrolled_text_tab2.insert(tkinter.INSERT, aTag)
        window.update()
        time.sleep(0.025)

    for tagForm in formTag:
        linkswithFormAction.append(tagForm.rstrip("\n"))

    for attr in attribute:
        attributes.append(attr.rstrip("\n"))
    blind = PayloadsBlindBase()
    timebase = PayloadsTimeBase()
    if choose_to_Scan_type == "SQL":
        splitUrl(linkswithParameters, linkswithFormAction, attributes, payload_of_SQL, patternList_of_SQL,
                 error_message_of_SQL, base_url)
        for bindpayload in blind:
            checkblind(linkswithParameters, bindpayload)
        for timepayload in timebase:
            checktime(linkswithParameters,timepayload)

        file = open('vulnerability.txt', 'a+')
        file.write("\nHow to fix SQL injection vulnerability \n"
                   "\n Filtering metacharacters from user input "
                   "\n Using prepare statements "
                   "\n Using Stored Procedures"
                   "\n Validating user input"
                   "\n Limiting privileges"
                   "\n Hiding info from the error message"
                   "\n Updating your system"
                   "\n Updating your system"
                   "\n Keeping database credentials separate and encrypted"
                   "\n Disabling shell and any other functionalities you donâ€™t need ")

        file.close()

    else:
        splitUrl(linkswithParameters, linkswithFormAction, attributes, payload_of_XSS, patternList_of_XSS,
                 error_message_of_XSS, base_url)

        file = open('vulnerability.txt', 'a+')
        file.write("\nHow to fix XSS vulnerability \n"
                   "\n Encoding data on output"
                   "\n Filtering input on arrival"
                   "\n Sanitizing user input")
        file.close()
    end = time.time()
    file = open('vulnerability.txt', 'a+')
    if 'https'and 'http' not in file:
        file.write("\n Not Found Any Possible Vulnerability :-)" + "  " + str(baseUrl))
        file.write("\nProcess finish after {} second".format(end - start))
    # if 'http' not in file:
    #     file.write("\n Not Found Any Possible Vulnerability :-)" + "  " + str(baseUrl))
    #     file.write("\nProcess finish after {} second".format(end - start))
    file.close()
    # searchmethod = re.findall(r'(www|http:|https:)+[^\s]+[\w]', file)
    # window.title("Testing Complete !!!")
    # if not searchmethod:
    #     file.write("\n Not Found Any Possible Vulnerability :-)" + "  " + str(baseUrl))
    #     file.write("\nProcess finish after {} second".format(end - start))
    messagebox.showinfo("information", "Testing Complete !!!!!! \n")


# User_Input--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
label_frame_user_input = tkinter.LabelFrame(window, text="Welcome to Test yours Sites !!!",
                                            borderwidth="1", bg='#187bcd')
# relief="raised"
label_frame_user_input.pack(anchor=CENTER, fill="y", pady=20)

base_url_label = tkinter.Label(label_frame_user_input, text="Enter URL :: ", bg='#187bcd')
base_url_label.pack(anchor=W, padx=30, pady=5)
base_url_entry = tkinter.Entry(label_frame_user_input, width=80, bd=3, insertwidth=0.5)
base_url_entry.pack(padx=80, pady=4)

s = ttk.Style()  # Creating style element
s.configure('Wild.TRadiobutton',  # First argument is the name of style. Needs to end with: .TRadiobutton
            background='#187bcd'  # Setting background to our specified color above foreground='white'
            )
var = StringVar()
var.set("SQL")
SQL_radio_button = ttk.Radiobutton(label_frame_user_input, text="SQL", variable=var, value="SQL",
                                   style='Wild.TRadiobutton')
SQL_radio_button.pack(side=LEFT, pady=4, padx=30)
XSS_radio_button = ttk.Radiobutton(label_frame_user_input, text="XSS", variable=var, value="XSS",
                                   style='Wild.TRadiobutton')
XSS_radio_button.pack(side=LEFT, pady=4)

start_Button = tkinter.Button(label_frame_user_input, text="Start",
                              command=lambda: main_page_click(var.get(), base_url_entry.get()), fg="red",
                              bg="white", width=10, relief="groove", borderwidth="4")
start_Button.pack(side=RIGHT, pady=4, padx=30)


# ------------------------------------------------------------------------------------------------------------------------------------------------------
# Tab Control
tabControl = ttk.Notebook(window)
# ttk.Style().configure("TNotebook", background="gray")
ttk.Style().configure("TNotebook", background="white")
ttk.Style().map("TNotebook.Tab", background=[("selected", "#187bcd")], foreground=[("selected", "red")]);

tab1 = ttk.Frame(tabControl)
tab2 = ttk.Frame(tabControl)
tab3 = ttk.Frame(tabControl)

tabControl.add(tab1, text="Crawl Page")
tabControl.add(tab2, text='Links_with_Parameters')
tabControl.add(tab3, text='Testing.....')

tabControl.pack(expand=1, fill="both")

scrolled_text_tab1 = scrolledtext.ScrolledText(tab1, wrap=tkinter.WORD)
scrolled_text_tab1.pack(fill="both", expand=1)
scrolled_text_tab2 = scrolledtext.ScrolledText(tab2, wrap=tkinter.WORD)
scrolled_text_tab2.pack(fill="both", expand=1)
scrolled_text_tab3 = scrolledtext.ScrolledText(tab3, wrap=tkinter.WORD)
scrolled_text_tab3.pack(fill="both", expand=1)

tagA = read_file_contents_a("linkfile.txt")
for a in tagA:
    scrolled_text_tab2.insert(tkinter.INSERT, a)
    window.update()
    time.sleep(0.025)

# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Exit Button
exit_button = tkinter.Button(window, text="Exit", command=exit, width=10, fg="red")
exit_button.pack(side=RIGHT, padx=8)
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# For accuracy Button
test_accuracy_button = tkinter.Button(window, text="Tested_Accuracy", command=lambda: testing_accuracy(), width="20",
                                      fg="blue", bg="#187bcd")
test_accuracy_button.pack(side=RIGHT)
window.mainloop()
